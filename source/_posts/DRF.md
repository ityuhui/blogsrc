title: Dominant Resource Fairness算法

date: 2020-06-20 21:36:36

categories:
- 大数据和分布式计算

tags:
- 资源调度
- DRF

---

## 1. 介绍

DRF算法是用于资源调度的算法，被yarn和mesos的调度器所采用。

## 2. 动机

基于slot的算法，不是没有用尽资源，就是过度使用资源。

## 3. 分配的属性

为了可以评估一个算法是否公平，论文提出了四个属性，以此来指导算法的开发。

### Sharing incentive

每一个用户应该更好的分享集群里的资源，而不是排他性使用他所有的那一部分。假设一个集群里有相同的机器和n个用户，每个用户都不可能在一个1/n资源分区里分配更多的任务。

### Strategy-proofness

用户不可能通过撒谎的方式，获得更多的资源。

### Envy-freeness

一个用户不能获的另外一个用户的分配资源。

### Pareto efficiency

如果一个用户没有降低他的分配，那么其他用户不可能提高分配。

## 4. DRF算法

DRF算法满足前一章所提出的四个属性。对于每一个用户，DRF计算出给该用户分配的每一个资源的份额。一个用户的所有的资源份额中，数量最大的，被称之为该用户的“主导份额”，该资源被称之该用户的“主导资源”。不同的用户可能有不同的主导资源。

### 4.1 例子

假设一个系统，有9 CPU，18GB 内存。两个用户，A运行任务（1 CPU，4 GB），B运行任务(3 CPU, 1 GB)。

用户A的每个task消耗1/9的总CPU，2/9的总内存，所以A的主导资源是内存。

用户B的每个task消耗1/3的总CPU，1/18的总内存，所以B的主导资源是CPU。

DRF算法会让所有用户的主导份额保持相等：
A执行3个Task, 共消耗（3 CPU， 12 GB）
B执行2个Task，共消耗（6 CPU， 2 GB）
在这个分配下，每个用户都获得了相等的主导份额：
A得到了2/3的总内存，B得到了2/3的总CPU

这一分配可以使用数学计算来表达，设x是A的task数，y是B的task数，那么，A收到（x CPU,4x GB）, B得到（3y CPU , y GB）, 总的资源分配是（x+3y CPU, 4x+y GB）, 让A的主导份额 4x/18 等于B的主导份额 3y/9, 那么，DRF的计算如下：

max(x,y)
需要满足：

```c
x + 3y <= 9
4x + y <= 18
2x / 9 = y / 3
```

解答这个问题可得

```c
x = 3
y = 2
```

因此,A得到（3 CPU，12 GB），B得到（6 CPU，2 GB）

注意，DRF并不需要让用户的主导份额总是相等。当一个用户的总需求已经得到满足，该用户就不会在需要新的task，因此超过的资源会被其他用户分配，就像max-min fairness一样，除此之外，如果一个资源已经耗尽，不需要该资源的用户可以继续得到更高份额的其他资源。

### 4.2 DRF 调度算法

4.1说的是最终的分配结果，并没有给出具体的每一步的算法，下面来详细说明算法：

在每一步，DRF挑出主导份额最小的用户，（刚开始都是0，所以随便选一个），如果有足够的资源可以启动一个task,那么就分配资源给该用户，启动Task, 直到系统里没有资源可用。

假设第一步挑出了B，那么B的份额变成了（3/9， 1/18），B的主导份额是1/3，这个时候A的主导份额是0，开始调度A。

A得到（1/9，4/18），A的主导份额变成了2/9，还是比B的主导份额小，所以接下来还是调度A。

A变成（2/9，8/18），A的主导份额变成了4/9，大于B的主导份额1/3，所以接下来调度B。

一直到最后，A和B的主导份额都变成了2/3，这个时候集群里的CPU分配完了，调度无法继续，调度结束。

在这个例子里，分配停止是因为资源用光了。但是，一般情况下，当某个资源用光了以后，分配可能还会继续，因为有些task根本不需要这种被用光的资源。

上述算法可以使用二叉堆来存储每一个用户的主导份额，每一次对n的用户的调度的时间复杂度是O(log n)

### 4.3 加权的DRF
